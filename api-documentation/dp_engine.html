<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>PipelineDP Â· pipeline_dp.dp_engine</title>
<meta name="description" content="DP aggregations." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
    <link rel="stylesheet" href="/assets/css/style.css">
</head>
<header class="o-wrapper c-header">
  <a href="/">
    <img class="c-header__logo" src="/assets/images/pipelinedp-color-lockup.svg" width="159" height="28" alt="PipelineDP">
  </a>
  <nav class="c-header__nav">
    <ul class="c-header__list">
      <li class="c-header__item">
        <a class="c-header__link " href="/get-started/">Get started</a>
      </li>
      <li class="c-header__item">
        <a class="c-header__link is-active" href="/overview/">Overview</a>
      </li>
      <li class="c-header__item">
        <a class="c-header__link " href="/api-documentation/index.html">API documentation</a>
      </li>
    </ul>
  </nav>
</header>
<main class="o-wrapper">
<article id="content">
<header>
<h1 class="title">Module <code>pipeline_dp.dp_engine</code></h1>
</header>
<section id="section-intro">
<p>DP aggregations.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;DP aggregations.&#34;&#34;&#34;
import math
import dataclasses
import functools
from typing import Any, Callable, Tuple
import numpy as np

import pipeline_dp
from pipeline_dp import combiners
import pipeline_dp.report_generator as report_generator

import pydp.algorithms.partition_selection as partition_selection


@dataclasses.dataclass
class DataExtractors:
    &#34;&#34;&#34;Data extractors.

    A set of functions that, given an input, return the privacy id, partition key,
    and value.
    &#34;&#34;&#34;

    privacy_id_extractor: Callable = None
    partition_extractor: Callable = None
    value_extractor: Callable = None


class DPEngine:
    &#34;&#34;&#34;Performs DP aggregations.&#34;&#34;&#34;

    def __init__(self, budget_accountant: &#39;BudgetAccountant&#39;,
                 backend: &#39;PipelineBackend&#39;):
        self._budget_accountant = budget_accountant
        self._backend = backend
        self._report_generators = []

    def _add_report_stage(self, text):
        self._report_generators[-1].add_stage(text)

    def aggregate(self, col, params: pipeline_dp.AggregateParams,
                  data_extractors: DataExtractors):
        &#34;&#34;&#34;Computes DP aggregation metrics.

        Args:
          col: collection with elements of the same type.
          params: specifies which metrics to compute and computation parameters.
          data_extractors: functions that extract needed pieces of information
            from elements of &#39;col&#39;.
        &#34;&#34;&#34;
        self._check_aggregate_params(col, params, data_extractors)

        with self._budget_accountant.scope(weight=params.budget_weight):
            return self._aggregate(col, params, data_extractors)

    def _aggregate(self, col, params: pipeline_dp.AggregateParams,
                   data_extractors: DataExtractors):

        self._report_generators.append(report_generator.ReportGenerator(params))

        combiner = combiners.create_compound_combiner(params,
                                                      self._budget_accountant)

        if params.public_partitions is not None:
            col = self._drop_not_public_partitions(col,
                                                   params.public_partitions,
                                                   data_extractors)

        # Extract the columns.
        col = self._backend.map(
            col, lambda row: (data_extractors.privacy_id_extractor(row),
                              data_extractors.partition_extractor(row),
                              data_extractors.value_extractor(row)),
            &#34;Extract (privacy_id, partition_key, value))&#34;)
        # col : (privacy_id, partition_key, value)
        col = self._bound_contributions(col, params.max_partitions_contributed,
                                        params.max_contributions_per_partition,
                                        combiner.create_accumulator)
        # col : ((privacy_id, partition_key), accumulator)

        col = self._backend.map_tuple(col, lambda pid_pk, v: (pid_pk[1], v),
                                      &#34;Drop privacy id&#34;)
        # col : (partition_key, accumulator)

        if params.public_partitions:
            col = self._add_empty_public_partitions(col,
                                                    params.public_partitions,
                                                    combiner.create_accumulator)
        # col : (partition_key, accumulator)

        col = self._backend.combine_accumulators_per_key(
            col, combiner, &#34;Reduce accumulators per partition key&#34;)
        # col : (partition_key, accumulator)

        if params.public_partitions is None:
            col = self._select_private_partitions_internal(
                col, params.max_partitions_contributed)
        else:
            pass
        # col : (partition_key, accumulator)

        # Compute DP metrics.
        col = self._backend.map_values(col, combiner.compute_metrics,
                                       &#34;Compute DP` metrics&#34;)
        return col

    def _check_aggregate_params(self, col, params: pipeline_dp.AggregateParams,
                                data_extractors: DataExtractors):
        if col is None or not col:
            raise ValueError(&#34;col must be non-empty&#34;)
        if params is None:
            raise ValueError(&#34;params must be set to a valid AggregateParams&#34;)
        if not isinstance(params, pipeline_dp.AggregateParams):
            raise TypeError(&#34;params must be set to a valid AggregateParams&#34;)
        if not isinstance(params.max_partitions_contributed,
                          int) or params.max_partitions_contributed &lt;= 0:
            raise ValueError(&#34;params.max_partitions_contributed must be set &#34;
                             &#34;to a positive integer&#34;)
        if not isinstance(params.max_contributions_per_partition,
                          int) or params.max_contributions_per_partition &lt;= 0:
            raise ValueError(
                &#34;params.max_contributions_per_partition must be set &#34;
                &#34;to a positive integer&#34;)
        needs_min_max_value = pipeline_dp.Metrics.SUM in params.metrics
        if needs_min_max_value and (params.min_value is None or
                                    params.max_value is None):
            raise ValueError(
                &#34;params.min_value and params.max_value must be set&#34;)
        if needs_min_max_value and (
                self._not_a_proper_number(params.min_value) or
                self._not_a_proper_number(params.max_value)):
            raise ValueError(
                &#34;params.min_value and params.max_value must be both finite numbers&#34;
            )
        if needs_min_max_value and params.max_value &lt; params.min_value:
            raise ValueError(
                &#34;params.max_value must be equal to or greater than params.min_value&#34;
            )
        if data_extractors is None:
            raise ValueError(&#34;data_extractors must be set to a DataExtractors&#34;)
        if not isinstance(data_extractors, pipeline_dp.DataExtractors):
            raise TypeError(&#34;data_extractors must be set to a DataExtractors&#34;)

    def _check_select_private_partitions(
            self, col, params: pipeline_dp.SelectPrivatePartitionsParams,
            data_extractors: DataExtractors):
        if col is None or not col:
            raise ValueError(&#34;col must be non-empty&#34;)
        if params is None:
            raise ValueError(
                &#34;params must be set to a valid SelectPrivatePartitionsParams&#34;)
        if not isinstance(params, pipeline_dp.SelectPrivatePartitionsParams):
            raise TypeError(
                &#34;params must be set to a valid SelectPrivatePartitionsParams&#34;)
        if not isinstance(params.max_partitions_contributed,
                          int) or params.max_partitions_contributed &lt;= 0:
            raise ValueError(&#34;params.max_partitions_contributed must be set &#34;
                             &#34;(to a positive integer)&#34;)
        if data_extractors is None:
            raise ValueError(&#34;data_extractors must be set to a DataExtractors&#34;)
        if not isinstance(data_extractors, pipeline_dp.DataExtractors):
            raise TypeError(&#34;data_extractors must be set to a DataExtractors&#34;)

    def select_private_partitions(
            self, col, params: pipeline_dp.SelectPrivatePartitionsParams,
            data_extractors: DataExtractors):
        &#34;&#34;&#34;Retrieves a collection of differentially-private partitions.

        Args:
          col: collection with elements of the same type.
          params: parameters, see doc for SelectPrivatePartitionsParams.
          data_extractors: functions that extract needed pieces of information
            from elements of &#39;col&#39;. Only privacy_id_extractor and partition_extractor are required.
            value_extractor is not required.
        &#34;&#34;&#34;
        self._check_select_private_partitions(col, params, data_extractors)

        self._report_generators.append(report_generator.ReportGenerator(params))
        max_partitions_contributed = params.max_partitions_contributed

        # Extract the columns.
        col = self._backend.map(
            col, lambda row: (data_extractors.privacy_id_extractor(row),
                              data_extractors.partition_extractor(row)),
            &#34;Extract (privacy_id, partition_key))&#34;)
        # col : (privacy_id, partition_key)

        # Apply cross-partition contribution bounding
        col = self._backend.group_by_key(col, &#34;Group by privacy_id&#34;)

        # col : (privacy_id, [partition_key])

        # Note: This may not be scalable if a single privacy ID contributes
        # to _way_ too many partitions.
        def sample_unique_elements_fn(pid_and_pks):
            pid, pks = pid_and_pks
            unique_pks = list(set(pks))
            if len(unique_pks) &lt;= max_partitions_contributed:
                sampled_elements = unique_pks
            else:
                # np.random.choice makes casting of elements to numpy types
                # which is undesirable by 2 reasons:
                # 1. Apache Beam can not serialize numpy types.
                # 2. It might lead for losing precision (e.g. arbitrary
                # precision int is converted to int64).
                # So np.random.choice should not be applied directly to
                # &#39;unique_pks&#39;. It is better to apply it to indices.
                sampled_indices = np.random.choice(np.arange(len(unique_pks)),
                                                   max_partitions_contributed,
                                                   replace=False)

                sampled_elements = [unique_pks[i] for i in sampled_indices]

            return ((pid, pk) for pk in sampled_elements)

        col = self._backend.flat_map(col, sample_unique_elements_fn,
                                     &#34;Sample cross-partition contributions&#34;)
        # col : (privacy_id, partition_key)

        # A compound accumulator without any child accumulators is used to calculate the raw privacy ID count.
        compound_combiner = combiners.CompoundCombiner([])
        col = self._backend.map_tuple(
            col, lambda pid, pk: (pk, compound_combiner.create_accumulator([])),
            &#34;Drop privacy id and add accumulator&#34;)
        # col : (partition_key, accumulator)

        col = self._backend.combine_accumulators_per_key(
            col, compound_combiner, &#34;Combine accumulators per partition key&#34;)
        # col : (partition_key, accumulator)

        col = self._select_private_partitions_internal(
            col, max_partitions_contributed)
        col = self._backend.keys(col,
                                 &#34;Drop accumulators, keep only partition keys&#34;)

        return col

    def _drop_not_public_partitions(self, col, public_partitions,
                                    data_extractors: DataExtractors):
        &#34;&#34;&#34;Drops partitions in `col` which are not in `public_partitions`.&#34;&#34;&#34;
        col = self._backend.map(
            col, lambda row: (data_extractors.partition_extractor(row), row),
            &#34;Extract partition id&#34;)
        col = self._backend.filter_by_key(
            col, public_partitions, &#34;Filtering out non-public partitions&#34;)
        self._add_report_stage(
            f&#34;Public partition selection: dropped non public partitions&#34;)
        return self._backend.map_tuple(col, lambda k, v: v, &#34;Drop key&#34;)

    def _add_empty_public_partitions(self, col, public_partitions,
                                     aggregator_fn):
        &#34;&#34;&#34;Adds empty accumulators to all `public_partitions` and returns those
        empty accumulators joined with `col`.&#34;&#34;&#34;
        self._add_report_stage(
            &#34;Adding empty partitions to public partitions that are missing in &#34;
            &#34;data&#34;)
        empty_accumulators = self._backend.map(
            public_partitions, lambda partition_key:
            (partition_key, aggregator_fn([])), &#34;Build empty accumulators&#34;)

        return self._backend.flatten(
            col, empty_accumulators,
            &#34;Join public partitions with partitions from data&#34;)

    def _bound_contributions(self, col, max_partitions_contributed: int,
                             max_contributions_per_partition: int,
                             aggregator_fn):
        &#34;&#34;&#34;Bounds the contribution by privacy_id in and cross partitions.

        Args:
          col: collection, with types of each element: (privacy_id,
            partition_key, value).
          max_partitions_contributed: maximum number of partitions that one
            privacy id can contribute to.
          max_contributions_per_partition: maximum number of records that one
            privacy id can contribute to one partition.
          aggregator_fn: function that takes a list of values and returns an
            aggregator object which handles all aggregation logic.

        return: collection with elements ((privacy_id, partition_key),
              accumulator).
        &#34;&#34;&#34;
        # per partition-contribution bounding with bounding of each contribution
        col = self._backend.map_tuple(
            col, lambda pid, pk, v: ((pid, pk), v),
            &#34;Rekey to ( (privacy_id, partition_key), value))&#34;)
        col = self._backend.sample_fixed_per_key(
            col, max_contributions_per_partition,
            &#34;Sample per (privacy_id, partition_key)&#34;)
        self._add_report_stage(
            f&#34;Per-partition contribution bounding: randomly selected not &#34;
            f&#34;more than {max_contributions_per_partition} contributions&#34;)
        # ((privacy_id, partition_key), [value])
        col = self._backend.map_values(
            col, aggregator_fn,
            &#34;Apply aggregate_fn after per partition bounding&#34;)
        # ((privacy_id, partition_key), accumulator)

        # Cross partition bounding
        col = self._backend.map_tuple(
            col, lambda pid_pk, v: (pid_pk[0], (pid_pk[1], v)),
            &#34;Rekey to (privacy_id, (partition_key, &#34;
            &#34;accumulator))&#34;)
        col = self._backend.sample_fixed_per_key(col,
                                                 max_partitions_contributed,
                                                 &#34;Sample per privacy_id&#34;)

        self._add_report_stage(
            f&#34;Cross-partition contribution bounding: randomly selected not more than &#34;
            f&#34;{max_partitions_contributed} partitions per user&#34;)

        # (privacy_id, [(partition_key, accumulator)])
        def unnest_cross_partition_bound_sampled_per_key(pid_pk_v):
            pid, pk_values = pid_pk_v
            return (((pid, pk), v) for (pk, v) in pk_values)

        return self._backend.flat_map(
            col, unnest_cross_partition_bound_sampled_per_key, &#34;Unnest&#34;)

    def _select_private_partitions_internal(self, col,
                                            max_partitions_contributed: int):
        &#34;&#34;&#34;Selects and publishes private partitions.

        Args:
            col: collection, with types for each element:
                (partition_key, Accumulator)
            max_partitions_contributed: maximum amount of partitions that one privacy unit
                might contribute.

        Returns:
            collection of elements (partition_key, accumulator)
        &#34;&#34;&#34;
        budget = self._budget_accountant.request_budget(
            mechanism_type=pipeline_dp.MechanismType.GENERIC)

        def filter_fn(
            budget: &#39;MechanismSpec&#39;, max_partitions: int,
            row: Tuple[Any,
                       combiners.CompoundCombiner.AccumulatorType]) -&gt; bool:
            &#34;&#34;&#34;Lazily creates a partition selection strategy and uses it to determine which
            partitions to keep.&#34;&#34;&#34;
            pirvacy_id_count, _ = row[1]
            partition_selection_strategy = (
                partition_selection.
                create_truncated_geometric_partition_strategy(
                    budget.eps, budget.delta, max_partitions))
            return partition_selection_strategy.should_keep(pirvacy_id_count)

        # make filter_fn serializable
        filter_fn = functools.partial(filter_fn, budget,
                                      max_partitions_contributed)
        self._add_report_stage(
            lambda:
            f&#34;Private Partition selection: using {budget.mechanism_type.value} &#34;
            f&#34;method with (eps= {budget.eps}, delta = {budget.delta})&#34;)

        return self._backend.filter(col, filter_fn, &#34;Filter private partitions&#34;)

    def _not_a_proper_number(self, num):
        &#34;&#34;&#34;
        Returns:
            true if num is inf or NaN, false otherwise.
        &#34;&#34;&#34;
        return math.isnan(num) or math.isinf(num)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pipeline_dp.dp_engine.DPEngine"><code class="flex name class">
<span>class <span class="ident">DPEngine</span></span>
<span>(</span><span>budget_accountant:Â BudgetAccountant, backend:Â PipelineBackend)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs DP aggregations.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DPEngine:
    &#34;&#34;&#34;Performs DP aggregations.&#34;&#34;&#34;

    def __init__(self, budget_accountant: &#39;BudgetAccountant&#39;,
                 backend: &#39;PipelineBackend&#39;):
        self._budget_accountant = budget_accountant
        self._backend = backend
        self._report_generators = []

    def _add_report_stage(self, text):
        self._report_generators[-1].add_stage(text)

    def aggregate(self, col, params: pipeline_dp.AggregateParams,
                  data_extractors: DataExtractors):
        &#34;&#34;&#34;Computes DP aggregation metrics.

        Args:
          col: collection with elements of the same type.
          params: specifies which metrics to compute and computation parameters.
          data_extractors: functions that extract needed pieces of information
            from elements of &#39;col&#39;.
        &#34;&#34;&#34;
        self._check_aggregate_params(col, params, data_extractors)

        with self._budget_accountant.scope(weight=params.budget_weight):
            return self._aggregate(col, params, data_extractors)

    def _aggregate(self, col, params: pipeline_dp.AggregateParams,
                   data_extractors: DataExtractors):

        self._report_generators.append(report_generator.ReportGenerator(params))

        combiner = combiners.create_compound_combiner(params,
                                                      self._budget_accountant)

        if params.public_partitions is not None:
            col = self._drop_not_public_partitions(col,
                                                   params.public_partitions,
                                                   data_extractors)

        # Extract the columns.
        col = self._backend.map(
            col, lambda row: (data_extractors.privacy_id_extractor(row),
                              data_extractors.partition_extractor(row),
                              data_extractors.value_extractor(row)),
            &#34;Extract (privacy_id, partition_key, value))&#34;)
        # col : (privacy_id, partition_key, value)
        col = self._bound_contributions(col, params.max_partitions_contributed,
                                        params.max_contributions_per_partition,
                                        combiner.create_accumulator)
        # col : ((privacy_id, partition_key), accumulator)

        col = self._backend.map_tuple(col, lambda pid_pk, v: (pid_pk[1], v),
                                      &#34;Drop privacy id&#34;)
        # col : (partition_key, accumulator)

        if params.public_partitions:
            col = self._add_empty_public_partitions(col,
                                                    params.public_partitions,
                                                    combiner.create_accumulator)
        # col : (partition_key, accumulator)

        col = self._backend.combine_accumulators_per_key(
            col, combiner, &#34;Reduce accumulators per partition key&#34;)
        # col : (partition_key, accumulator)

        if params.public_partitions is None:
            col = self._select_private_partitions_internal(
                col, params.max_partitions_contributed)
        else:
            pass
        # col : (partition_key, accumulator)

        # Compute DP metrics.
        col = self._backend.map_values(col, combiner.compute_metrics,
                                       &#34;Compute DP` metrics&#34;)
        return col

    def _check_aggregate_params(self, col, params: pipeline_dp.AggregateParams,
                                data_extractors: DataExtractors):
        if col is None or not col:
            raise ValueError(&#34;col must be non-empty&#34;)
        if params is None:
            raise ValueError(&#34;params must be set to a valid AggregateParams&#34;)
        if not isinstance(params, pipeline_dp.AggregateParams):
            raise TypeError(&#34;params must be set to a valid AggregateParams&#34;)
        if not isinstance(params.max_partitions_contributed,
                          int) or params.max_partitions_contributed &lt;= 0:
            raise ValueError(&#34;params.max_partitions_contributed must be set &#34;
                             &#34;to a positive integer&#34;)
        if not isinstance(params.max_contributions_per_partition,
                          int) or params.max_contributions_per_partition &lt;= 0:
            raise ValueError(
                &#34;params.max_contributions_per_partition must be set &#34;
                &#34;to a positive integer&#34;)
        needs_min_max_value = pipeline_dp.Metrics.SUM in params.metrics
        if needs_min_max_value and (params.min_value is None or
                                    params.max_value is None):
            raise ValueError(
                &#34;params.min_value and params.max_value must be set&#34;)
        if needs_min_max_value and (
                self._not_a_proper_number(params.min_value) or
                self._not_a_proper_number(params.max_value)):
            raise ValueError(
                &#34;params.min_value and params.max_value must be both finite numbers&#34;
            )
        if needs_min_max_value and params.max_value &lt; params.min_value:
            raise ValueError(
                &#34;params.max_value must be equal to or greater than params.min_value&#34;
            )
        if data_extractors is None:
            raise ValueError(&#34;data_extractors must be set to a DataExtractors&#34;)
        if not isinstance(data_extractors, pipeline_dp.DataExtractors):
            raise TypeError(&#34;data_extractors must be set to a DataExtractors&#34;)

    def _check_select_private_partitions(
            self, col, params: pipeline_dp.SelectPrivatePartitionsParams,
            data_extractors: DataExtractors):
        if col is None or not col:
            raise ValueError(&#34;col must be non-empty&#34;)
        if params is None:
            raise ValueError(
                &#34;params must be set to a valid SelectPrivatePartitionsParams&#34;)
        if not isinstance(params, pipeline_dp.SelectPrivatePartitionsParams):
            raise TypeError(
                &#34;params must be set to a valid SelectPrivatePartitionsParams&#34;)
        if not isinstance(params.max_partitions_contributed,
                          int) or params.max_partitions_contributed &lt;= 0:
            raise ValueError(&#34;params.max_partitions_contributed must be set &#34;
                             &#34;(to a positive integer)&#34;)
        if data_extractors is None:
            raise ValueError(&#34;data_extractors must be set to a DataExtractors&#34;)
        if not isinstance(data_extractors, pipeline_dp.DataExtractors):
            raise TypeError(&#34;data_extractors must be set to a DataExtractors&#34;)

    def select_private_partitions(
            self, col, params: pipeline_dp.SelectPrivatePartitionsParams,
            data_extractors: DataExtractors):
        &#34;&#34;&#34;Retrieves a collection of differentially-private partitions.

        Args:
          col: collection with elements of the same type.
          params: parameters, see doc for SelectPrivatePartitionsParams.
          data_extractors: functions that extract needed pieces of information
            from elements of &#39;col&#39;. Only privacy_id_extractor and partition_extractor are required.
            value_extractor is not required.
        &#34;&#34;&#34;
        self._check_select_private_partitions(col, params, data_extractors)

        self._report_generators.append(report_generator.ReportGenerator(params))
        max_partitions_contributed = params.max_partitions_contributed

        # Extract the columns.
        col = self._backend.map(
            col, lambda row: (data_extractors.privacy_id_extractor(row),
                              data_extractors.partition_extractor(row)),
            &#34;Extract (privacy_id, partition_key))&#34;)
        # col : (privacy_id, partition_key)

        # Apply cross-partition contribution bounding
        col = self._backend.group_by_key(col, &#34;Group by privacy_id&#34;)

        # col : (privacy_id, [partition_key])

        # Note: This may not be scalable if a single privacy ID contributes
        # to _way_ too many partitions.
        def sample_unique_elements_fn(pid_and_pks):
            pid, pks = pid_and_pks
            unique_pks = list(set(pks))
            if len(unique_pks) &lt;= max_partitions_contributed:
                sampled_elements = unique_pks
            else:
                # np.random.choice makes casting of elements to numpy types
                # which is undesirable by 2 reasons:
                # 1. Apache Beam can not serialize numpy types.
                # 2. It might lead for losing precision (e.g. arbitrary
                # precision int is converted to int64).
                # So np.random.choice should not be applied directly to
                # &#39;unique_pks&#39;. It is better to apply it to indices.
                sampled_indices = np.random.choice(np.arange(len(unique_pks)),
                                                   max_partitions_contributed,
                                                   replace=False)

                sampled_elements = [unique_pks[i] for i in sampled_indices]

            return ((pid, pk) for pk in sampled_elements)

        col = self._backend.flat_map(col, sample_unique_elements_fn,
                                     &#34;Sample cross-partition contributions&#34;)
        # col : (privacy_id, partition_key)

        # A compound accumulator without any child accumulators is used to calculate the raw privacy ID count.
        compound_combiner = combiners.CompoundCombiner([])
        col = self._backend.map_tuple(
            col, lambda pid, pk: (pk, compound_combiner.create_accumulator([])),
            &#34;Drop privacy id and add accumulator&#34;)
        # col : (partition_key, accumulator)

        col = self._backend.combine_accumulators_per_key(
            col, compound_combiner, &#34;Combine accumulators per partition key&#34;)
        # col : (partition_key, accumulator)

        col = self._select_private_partitions_internal(
            col, max_partitions_contributed)
        col = self._backend.keys(col,
                                 &#34;Drop accumulators, keep only partition keys&#34;)

        return col

    def _drop_not_public_partitions(self, col, public_partitions,
                                    data_extractors: DataExtractors):
        &#34;&#34;&#34;Drops partitions in `col` which are not in `public_partitions`.&#34;&#34;&#34;
        col = self._backend.map(
            col, lambda row: (data_extractors.partition_extractor(row), row),
            &#34;Extract partition id&#34;)
        col = self._backend.filter_by_key(
            col, public_partitions, &#34;Filtering out non-public partitions&#34;)
        self._add_report_stage(
            f&#34;Public partition selection: dropped non public partitions&#34;)
        return self._backend.map_tuple(col, lambda k, v: v, &#34;Drop key&#34;)

    def _add_empty_public_partitions(self, col, public_partitions,
                                     aggregator_fn):
        &#34;&#34;&#34;Adds empty accumulators to all `public_partitions` and returns those
        empty accumulators joined with `col`.&#34;&#34;&#34;
        self._add_report_stage(
            &#34;Adding empty partitions to public partitions that are missing in &#34;
            &#34;data&#34;)
        empty_accumulators = self._backend.map(
            public_partitions, lambda partition_key:
            (partition_key, aggregator_fn([])), &#34;Build empty accumulators&#34;)

        return self._backend.flatten(
            col, empty_accumulators,
            &#34;Join public partitions with partitions from data&#34;)

    def _bound_contributions(self, col, max_partitions_contributed: int,
                             max_contributions_per_partition: int,
                             aggregator_fn):
        &#34;&#34;&#34;Bounds the contribution by privacy_id in and cross partitions.

        Args:
          col: collection, with types of each element: (privacy_id,
            partition_key, value).
          max_partitions_contributed: maximum number of partitions that one
            privacy id can contribute to.
          max_contributions_per_partition: maximum number of records that one
            privacy id can contribute to one partition.
          aggregator_fn: function that takes a list of values and returns an
            aggregator object which handles all aggregation logic.

        return: collection with elements ((privacy_id, partition_key),
              accumulator).
        &#34;&#34;&#34;
        # per partition-contribution bounding with bounding of each contribution
        col = self._backend.map_tuple(
            col, lambda pid, pk, v: ((pid, pk), v),
            &#34;Rekey to ( (privacy_id, partition_key), value))&#34;)
        col = self._backend.sample_fixed_per_key(
            col, max_contributions_per_partition,
            &#34;Sample per (privacy_id, partition_key)&#34;)
        self._add_report_stage(
            f&#34;Per-partition contribution bounding: randomly selected not &#34;
            f&#34;more than {max_contributions_per_partition} contributions&#34;)
        # ((privacy_id, partition_key), [value])
        col = self._backend.map_values(
            col, aggregator_fn,
            &#34;Apply aggregate_fn after per partition bounding&#34;)
        # ((privacy_id, partition_key), accumulator)

        # Cross partition bounding
        col = self._backend.map_tuple(
            col, lambda pid_pk, v: (pid_pk[0], (pid_pk[1], v)),
            &#34;Rekey to (privacy_id, (partition_key, &#34;
            &#34;accumulator))&#34;)
        col = self._backend.sample_fixed_per_key(col,
                                                 max_partitions_contributed,
                                                 &#34;Sample per privacy_id&#34;)

        self._add_report_stage(
            f&#34;Cross-partition contribution bounding: randomly selected not more than &#34;
            f&#34;{max_partitions_contributed} partitions per user&#34;)

        # (privacy_id, [(partition_key, accumulator)])
        def unnest_cross_partition_bound_sampled_per_key(pid_pk_v):
            pid, pk_values = pid_pk_v
            return (((pid, pk), v) for (pk, v) in pk_values)

        return self._backend.flat_map(
            col, unnest_cross_partition_bound_sampled_per_key, &#34;Unnest&#34;)

    def _select_private_partitions_internal(self, col,
                                            max_partitions_contributed: int):
        &#34;&#34;&#34;Selects and publishes private partitions.

        Args:
            col: collection, with types for each element:
                (partition_key, Accumulator)
            max_partitions_contributed: maximum amount of partitions that one privacy unit
                might contribute.

        Returns:
            collection of elements (partition_key, accumulator)
        &#34;&#34;&#34;
        budget = self._budget_accountant.request_budget(
            mechanism_type=pipeline_dp.MechanismType.GENERIC)

        def filter_fn(
            budget: &#39;MechanismSpec&#39;, max_partitions: int,
            row: Tuple[Any,
                       combiners.CompoundCombiner.AccumulatorType]) -&gt; bool:
            &#34;&#34;&#34;Lazily creates a partition selection strategy and uses it to determine which
            partitions to keep.&#34;&#34;&#34;
            pirvacy_id_count, _ = row[1]
            partition_selection_strategy = (
                partition_selection.
                create_truncated_geometric_partition_strategy(
                    budget.eps, budget.delta, max_partitions))
            return partition_selection_strategy.should_keep(pirvacy_id_count)

        # make filter_fn serializable
        filter_fn = functools.partial(filter_fn, budget,
                                      max_partitions_contributed)
        self._add_report_stage(
            lambda:
            f&#34;Private Partition selection: using {budget.mechanism_type.value} &#34;
            f&#34;method with (eps= {budget.eps}, delta = {budget.delta})&#34;)

        return self._backend.filter(col, filter_fn, &#34;Filter private partitions&#34;)

    def _not_a_proper_number(self, num):
        &#34;&#34;&#34;
        Returns:
            true if num is inf or NaN, false otherwise.
        &#34;&#34;&#34;
        return math.isnan(num) or math.isinf(num)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="pipeline_dp.dp_engine.DPEngine.aggregate"><code class="name flex">
<span>def <span class="ident">aggregate</span></span>(<span>self, col, params:Â <a title="pipeline_dp.aggregate_params.AggregateParams" href="aggregate_params.html#pipeline_dp.aggregate_params.AggregateParams">AggregateParams</a>, data_extractors:Â <a title="pipeline_dp.dp_engine.DataExtractors" href="#pipeline_dp.dp_engine.DataExtractors">DataExtractors</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes DP aggregation metrics.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>col</code></strong></dt>
<dd>collection with elements of the same type.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>specifies which metrics to compute and computation parameters.</dd>
<dt><strong><code>data_extractors</code></strong></dt>
<dd>functions that extract needed pieces of information
from elements of 'col'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregate(self, col, params: pipeline_dp.AggregateParams,
              data_extractors: DataExtractors):
    &#34;&#34;&#34;Computes DP aggregation metrics.

    Args:
      col: collection with elements of the same type.
      params: specifies which metrics to compute and computation parameters.
      data_extractors: functions that extract needed pieces of information
        from elements of &#39;col&#39;.
    &#34;&#34;&#34;
    self._check_aggregate_params(col, params, data_extractors)

    with self._budget_accountant.scope(weight=params.budget_weight):
        return self._aggregate(col, params, data_extractors)</code></pre>
</details>
</dd>
<dt id="pipeline_dp.dp_engine.DPEngine.select_private_partitions"><code class="name flex">
<span>def <span class="ident">select_private_partitions</span></span>(<span>self, col, params:Â <a title="pipeline_dp.aggregate_params.SelectPrivatePartitionsParams" href="aggregate_params.html#pipeline_dp.aggregate_params.SelectPrivatePartitionsParams">SelectPrivatePartitionsParams</a>, data_extractors:Â <a title="pipeline_dp.dp_engine.DataExtractors" href="#pipeline_dp.dp_engine.DataExtractors">DataExtractors</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves a collection of differentially-private partitions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>col</code></strong></dt>
<dd>collection with elements of the same type.</dd>
<dt><strong><code>params</code></strong></dt>
<dd>parameters, see doc for SelectPrivatePartitionsParams.</dd>
<dt><strong><code>data_extractors</code></strong></dt>
<dd>functions that extract needed pieces of information
from elements of 'col'. Only privacy_id_extractor and partition_extractor are required.
value_extractor is not required.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_private_partitions(
        self, col, params: pipeline_dp.SelectPrivatePartitionsParams,
        data_extractors: DataExtractors):
    &#34;&#34;&#34;Retrieves a collection of differentially-private partitions.

    Args:
      col: collection with elements of the same type.
      params: parameters, see doc for SelectPrivatePartitionsParams.
      data_extractors: functions that extract needed pieces of information
        from elements of &#39;col&#39;. Only privacy_id_extractor and partition_extractor are required.
        value_extractor is not required.
    &#34;&#34;&#34;
    self._check_select_private_partitions(col, params, data_extractors)

    self._report_generators.append(report_generator.ReportGenerator(params))
    max_partitions_contributed = params.max_partitions_contributed

    # Extract the columns.
    col = self._backend.map(
        col, lambda row: (data_extractors.privacy_id_extractor(row),
                          data_extractors.partition_extractor(row)),
        &#34;Extract (privacy_id, partition_key))&#34;)
    # col : (privacy_id, partition_key)

    # Apply cross-partition contribution bounding
    col = self._backend.group_by_key(col, &#34;Group by privacy_id&#34;)

    # col : (privacy_id, [partition_key])

    # Note: This may not be scalable if a single privacy ID contributes
    # to _way_ too many partitions.
    def sample_unique_elements_fn(pid_and_pks):
        pid, pks = pid_and_pks
        unique_pks = list(set(pks))
        if len(unique_pks) &lt;= max_partitions_contributed:
            sampled_elements = unique_pks
        else:
            # np.random.choice makes casting of elements to numpy types
            # which is undesirable by 2 reasons:
            # 1. Apache Beam can not serialize numpy types.
            # 2. It might lead for losing precision (e.g. arbitrary
            # precision int is converted to int64).
            # So np.random.choice should not be applied directly to
            # &#39;unique_pks&#39;. It is better to apply it to indices.
            sampled_indices = np.random.choice(np.arange(len(unique_pks)),
                                               max_partitions_contributed,
                                               replace=False)

            sampled_elements = [unique_pks[i] for i in sampled_indices]

        return ((pid, pk) for pk in sampled_elements)

    col = self._backend.flat_map(col, sample_unique_elements_fn,
                                 &#34;Sample cross-partition contributions&#34;)
    # col : (privacy_id, partition_key)

    # A compound accumulator without any child accumulators is used to calculate the raw privacy ID count.
    compound_combiner = combiners.CompoundCombiner([])
    col = self._backend.map_tuple(
        col, lambda pid, pk: (pk, compound_combiner.create_accumulator([])),
        &#34;Drop privacy id and add accumulator&#34;)
    # col : (partition_key, accumulator)

    col = self._backend.combine_accumulators_per_key(
        col, compound_combiner, &#34;Combine accumulators per partition key&#34;)
    # col : (partition_key, accumulator)

    col = self._select_private_partitions_internal(
        col, max_partitions_contributed)
    col = self._backend.keys(col,
                             &#34;Drop accumulators, keep only partition keys&#34;)

    return col</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pipeline_dp.dp_engine.DataExtractors"><code class="flex name class">
<span>class <span class="ident">DataExtractors</span></span>
<span>(</span><span>privacy_id_extractor:Â CallableÂ =Â None, partition_extractor:Â CallableÂ =Â None, value_extractor:Â CallableÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Data extractors.</p>
<p>A set of functions that, given an input, return the privacy id, partition key,
and value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@dataclasses.dataclass
class DataExtractors:
    &#34;&#34;&#34;Data extractors.

    A set of functions that, given an input, return the privacy id, partition key,
    and value.
    &#34;&#34;&#34;

    privacy_id_extractor: Callable = None
    partition_extractor: Callable = None
    value_extractor: Callable = None</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pipeline_dp.dp_engine.DataExtractors.partition_extractor"><code class="name">var <span class="ident">partition_extractor</span> :Â Callable</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pipeline_dp.dp_engine.DataExtractors.privacy_id_extractor"><code class="name">var <span class="ident">privacy_id_extractor</span> :Â Callable</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pipeline_dp.dp_engine.DataExtractors.value_extractor"><code class="name">var <span class="ident">value_extractor</span> :Â Callable</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pipeline_dp" href="index.html">pipeline_dp</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pipeline_dp.dp_engine.DPEngine" href="#pipeline_dp.dp_engine.DPEngine">DPEngine</a></code></h4>
<ul class="">
<li><code><a title="pipeline_dp.dp_engine.DPEngine.aggregate" href="#pipeline_dp.dp_engine.DPEngine.aggregate">aggregate</a></code></li>
<li><code><a title="pipeline_dp.dp_engine.DPEngine.select_private_partitions" href="#pipeline_dp.dp_engine.DPEngine.select_private_partitions">select_private_partitions</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pipeline_dp.dp_engine.DataExtractors" href="#pipeline_dp.dp_engine.DataExtractors">DataExtractors</a></code></h4>
<ul class="">
<li><code><a title="pipeline_dp.dp_engine.DataExtractors.partition_extractor" href="#pipeline_dp.dp_engine.DataExtractors.partition_extractor">partition_extractor</a></code></li>
<li><code><a title="pipeline_dp.dp_engine.DataExtractors.privacy_id_extractor" href="#pipeline_dp.dp_engine.DataExtractors.privacy_id_extractor">privacy_id_extractor</a></code></li>
<li><code><a title="pipeline_dp.dp_engine.DataExtractors.value_extractor" href="#pipeline_dp.dp_engine.DataExtractors.value_extractor">value_extractor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
